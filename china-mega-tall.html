<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>DIR Case Study Wiki</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #0065bd;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #0065bd;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0a1628;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">DIR Case Study Wiki</p>
                        <p>Enter the password to access the DIR Case Study Wiki.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"431e614d2a626e664ba696f8d816ab466b4fe71d67d54991abc38dd9ebf925687e3f8896764b6fa4efa10b94e2d966845fc3a786fc86feb8d59908c0e7b9c174deed8fbacf5a7477859ea73570ccfb1ba083349106fc0b8e9639fb7d5df6f6cdd54076d3656da29335be5de7cea90d4934fa02937f858111610380d49aaf69359bc29cf93c9ff3aaebd65d126905226b66abef661428b3debce0ef9631fd0546ea65727ba247a723adc3bf30ec6ac5083969ecbb797debf02c93282d0cd7891f38a7cdb48c74a184d1ce28363c0bd6c6e32bebf1764859f7d4eb63d17e7c2218e2c9d86eb34363b4ab143eb6815a6f1870721246987fb2c5031eeccb8dc534cfece3602cf097029f57efecf34e523dc8932374ceb302e4ca9a712ffa95c173ef6ee468938d3377430f5e322def4cacfc9c2b04d07ef2af9eea2886c1b6e3f027ec573e56059f7a99aa11c06acde3184f2c93364b3a9a80578d478e531baf00a9f4f388f20df78580500e54747255906c5907201a6a3df2e24037238adfad9ba362c5694fc6b366f4c32756470132d58eeb5b28f247cca0a889b19399303057646290c3f4d161cc1bb5f50c921dd4e8f1b828234b6e898951f268a627e2ec2c5802493894808bd995e967dc2b733a93d4aa724baa088d275b67246844f4c3014e904437ab187829c17290ce63fba86e4dc6ce0bf797e27cc2ee9b17c110c01f6332f6f38fa7a4c58b73bcfd9043cf010d407a37409e57afbfaa96cd76fbc452a0f338676bb57982ad20bbbdf44b5355b03d429315564622262e16c746bbb5ff3d05c02ae95e76bba319585b938fc3bfe2d33cf5171d2a0cb81e126f396d8d70b03bdbd76e4dcb8dfee1ef0842ba54979832806e6f38df953230f008883c230e9164a13870b548ebe458c4c03d62e958d7073575656d3d8834a5090e28a7337952ad55ea145ae8b4cd212b4c41836a8523fcd9918c8a16ef1f956e018b081ef2c02c09bf2605fa4dc43e6867bb4aaf0eafc74e7a236c3a8b92775af4bc780ec6869993d62035a78cdd56f6adee4d809b2cf8f7d9c19d347327de4d205134c5be526a0de1853e715fa6bccaf5d3c4d4d9922d0aad0ed60953856648f09f970535bb5df2918f282fd840aeaa654ec4f9171d04d21f21e967fe5d252b270c4cd4ebac7bb4c8703549372fa7216f57c4385c42067ffc948dd62fae1db1f3b78dd02efd501502958ea65fdd307b4e153f083c97e3cc9ad25b6f787f861a0d6d2e7ce3797496f8c8cbdbb3604dd45ad62503cb1abb14bb24c25adf0d52b188babe14983e08873e8684f0aaa651152653b5b4f35011dd43f4fa2d5d7ac6c75afe3def3b5b8319b61a1474d261fbb36815f1bdf159fa22a0a46fcc804e021f1f9058aedceb5340ffaf57fd4809210dacd8919fe90497c204934dd21c7b1cc338f47a63c9f7de60edb54c31716e08b4b52636c6da04dbf4248ca1d2d3fd29812c1c93097711f687cea1ad573ee8ca0ea025640d5b207f944876a7f6394d2c68bb41d8e4e6912a63463f45990878fd6e9695eef34b04c021376585d659d1dc4a7ec728159c85b69cdd3bad28a474cc9beb03916ba5d5d88faddc0639bf9b2f5c59538b32dfcecd9827b78b27f167ed1cce4cdfc1e8209109003c4657d2511f9dfcfbebb0e91a3f41f534e3721d82ee2f1a30df2aecdd6d9f265de73acb2778bcaa6cd6077645d55ce6745fbbdb19a68bf0aad3823e5f5fa6bca3b7a3297d1f8da3acc9d3555e6ad81f8bc1d49736f22028e5f78a2fc71d7eb885065a5f4611a81f649d9dc1eed082d7c837779b5f21a0d8dd910a7534672c1b2fc7a1549e22f456c4c9ab1ec647ba4c614fc1647751a9128eb36472d41c6d277ff53fea55f8d418351e24afa4a59feb6b533a6572ef9afdbe17598e52397c31f9802b07e6e9635f9e88d90273ce0f9095012d04c52bdd80f268969159f78ac0d8c558fe5571f57c171dc765fe8de1709c8eb2cf5aca9de9023433d6ac4ca8f5cff52d45ccc40decfe143b214943c9e1d046995dd35456b609d8fca186416b1cce34769c667cb20978bc86ff55b7929c24f9d91c4539b47dfc81510d0b5701a1424dd79e93c7962562c7f719909a4bc2bef47afe0165dbcc3bca332a65796b95b45b3731a1dd4b770de666cfe8d4be035399f79cbf9491dc18a4542484997ee4c66c2aa9175e2c0515912b15eaa4d9c9f5052b532f50ffdc8602b475b2cdd6b494985f85bdb726ea1bbded995b07b5c4646ee2bef572a40793aedca5863162e0cb168260c19b1a28564de229dc7bdf4e68e6f0f1de4941b2e60c84b00a2bfba41135dbb0d6a8ead8376cd6ebc46d1153a25a459ef95ac0aee8b85872de281ee132b924e0e4f2960c767a2c7d1c3d3813bc6d98e79df9ea45c486ac8c6e8511451f64ff945e23291870f02583667caef08069b38bd2ac6e577767219e8a75b5cfe498300cf80308a1243187e991c3a2a7695b50b7ffc5a6f47da9e282a1a95e98a477373cc0af718176535cba2a9f4d279ff54e696f0317d3676d80b4700523a1a5a0ca1c9c1711675c88ff84e5552d81c4905e3492cbcf387b38329b84e41887228bc7ebbf1d27c4abafd5c5a6a995e1dae56289c7a52093468469511c5a8107cdd3d618c0131b3839cb4c83be455b67802177ab3d2ee511e1cb975e43d721e7a246c251e63aa8d57c198ba84ad4acfa34f9cff27b9abb46f589e4bb8afe03b24aa94ddeff390f2587678c51fb42ba47d1e617e2f6e95dab028b66e9d4515cc1ac44fb4053a8748d600ddb94381786b254d28f6a2ffab25f1fa997df92601b5823efc6f557a5379f94f7f2ee1de25e50b050e4175afe6957d6097faf5fd38479d027bdc58f3e34e3165f8ada4d61a2b129a3c53e1355edb591b0ff6248ad8d2d5e8d129374a6c0a61371d3d514cce1c45fdde20361612580f944e2b896ee5c5aba3223565d24acf9b73528bf1a624c53b03a4ffa3d895b09128592cecffc618601fd0ca070cd25e772e165ed8c964e410513822b90a345a13c5b8c45951794dce77b9477b9b6c6a4f75fcd462a4475d563002826f55db9fd999ac430140fe63b223b67d8abb1ad0774a3dfba49ed23d24615718843513fea6b361a6b951749a0162b0d38b66a45ce3123bab13c6496c0caa151d01a3093e373205127be12338b0d89817158a9f9c22b6489664cd77166e4001caa9856d76343878291a3bc8715a19559c31118e8ca32b90b6e4e7d40c51a72bc0e7017bd8b638f61040a89a28445a04e3242c5770495069a907235b4fb5419e6f3411e2985702142d7f3fc8bf2525793dfaff9f249e452ee2537b27c3d1e98b39711d56af860740dd475c42537376ba40c0bcf8eae15e213a0d138b6bd027dc8796f33969559bb1dc55339277c21509a575c19bd30891c9c26e34e95b12a09ff3ba72b32a77cc3fa9b9e8c48cc27354cc89011219147a552641be3962656495eadc8688aaeffee96d94eeae7070324d511f01682a50249c4eece273f92334d77c5f3a498ac7336e133ace7cb49575579ac787ec9708d8bfe2011797192907651bd20fa4713bcdfb7cc4881d2e2604237fb67e094036efe2e08e284bd15f271aeeb3f29386606bd238ec38749c6f24433d5cb34b020bdeb5ffa4db83b6b925f756f4103a97301420287f753aee83823901cb2de729614c92bfa4d436a6accf0c5d9a927926596f8ade5c5797082d4639ef95e71c3991409356bae58d926ee79abb172c9f677acf584eda9b361b4fb2dd165c39d3083dbbf2bd5bbf13aeafd7405b071f843e95cf36d6ed830aa3387f1511fa947b5ebffb2e6d9814d952ce5e89f66e896fbf732a3e0d24615697510bfae3c41ae0d46c9a57beec0c9f906b19614ee88e32dd85ee89b305ce754f1e385adbfdd1587ee0e7f128115cf9c4f2b3dbe376824019408c60000a3c8e44377d9290f966cca9067d16e9596e2aa38482c40dc327c9be9d86991d2c774b031eabd07a70d823364b07087b12448a012ffbe88a7138f533a449cb0e49d46a27a4db967f40bb6104028fed6ea27825f79f3a89276bd54b8b3676f23f69ffb80a809b5f07d498feba1e888f38c8722f17e07756cb22954b4534bbfb531c0faf2579a8a4dfd128b1860fc2582e2ab34f109d4c26180a1216cb135679284efbfd58869b35676b7b1ce6627c5fa1eb62eaa3ee209a26850367f506e7e46200a16198fba1d3ebac71e1a1f738b406a6a2de161121793a58d7d6c11cddeedcbfb46f629a39f3e82f062de0145fb1f41c8a2cb5b5155de1f56d7c177752df26db120fe3248427f7df8e2a3483193f9784e5b44621aff9e3bb64c53ea1860fa844a18059d7f0d33ac98e9fc9fa4798657c44ef03fc743b8cb882f4a599ff221ef0615df3d45922f37ace47c2baee54f1d8e6560db043bfeed2b32250541b246fad870bf9c1ed5305769ec32e16daad0dd100788f185ce5efbebcfce03b156d2d0f60a3db88cedcc3d8e1d209207c0eedabfa467899173cac591ffc31cbeefcf4c82de1c27c898228d4f638c6e495c05de3d4a01e9d5256ea98898b828c379140d3efc6f4066f2738fbf1ce9f40512947c4f20eb6f0394dfd264f6ced0a8ad1b3b4173340a88861c2533741572dd64809042f7aaee80f8a79660da1834bbb4009f755d02163e871776279b214bbb9d92fccc23ee8d1570d29e2127c17715a491c86bb95659942f8cd1de101db5da5409b7eb2a56c252b29376312ffd38a4802b1486334400fabb663e2f777a2cb435ef7bcf152bcb6aa819b13e45036e9dddbaae15e04a3ab88b6773c1afd0caca1f09dcaffeef344a88b6598b61074dd9a99b84183f90bda9542a4c2b3122e7a608f8486ee7a76c2e94cde1f831b8672d6a667fcc10b40e94fe11aba5830420bff9f7de381c145469cd9d4aac62e10022ddeb6965aa928e14be49df124de68c99d2bec3de7089ab60e7d4c64a17dbc920779c25c63a2450810b66322c805f915e70f4191496cd87783a4ac4630e1db90823a4e2314db4182a50ce77889f351611fee74fc143680b4b4b2543662aadc51acdb710c83f29e7828429ab085d50846217ba2dafee57fa0eabf4202559b4e39fe806bfde20728e489edfb85d390250d956883d5d53c80acaba04aefcb9f4575a0788a7ae109466de9bdaec0b680761a7b8062d5ae79cc94fe251d2057e85a4e1f82a967876ed441333bf5972cf7c768bc790808e7e29c952ae289c9a74589926792355ce8cd0ed4fd994c3984cb5b1df04cba2360990b7598d92cb1cfaa708ebdeacb7060e5191f954292539ca657e84ec630e4f17374dc7759f15e70b22e415670f1e32a9f5a5c9527aa1d9913d889ebf861cfb9ca49e9dfaa8859d9901e88a8002764fcc39a304dabdfb6db916bde8e7833ac810611bee6099b3f97c2bd0fbf8d3481ed6b4829467c89acb3ee7dda5675e5d5ea5c25474aaea555424b1ecfded54013b3b5b5b89d121a30f6cbb51570b9dddc3757d6d1616690f3069b00ecf9d568afa224ba156660813b3b9c74d2e497e5e8a7ff7672c487b49cc0241c3fd5fadf0cc9aee23dc29cc3a06ca8abdb30c8a18af16346aa794b62bc4be39acfab5cf6b30472c913d20ac821ed44cda4c5f3fb0c733eba8840216e83fae92fb4b01cc7aca25a3c2c6cd248015795e74d934cbdecfb57c9f7e94b1b503642dd05864ef11cfc33fc2ecbc000b1807051a0e88d92a19c5725630c0b45c8656ed72cf2724aaa9a7cffaa077b5df859e34ca1f4f4dedb58cdbc3d1e8bba743b15daa43f20d099ae810a7dc19bea0bec884dac5b58e5a8fb98fd56d6b9124f5862b75d3546dda4ff02c67e97886b25744cc5f8bf7f440595160491562938bda5fe81f3ff955e487bdd27859ef31874cfe65d05e5e3762199ce1c9a6c8754eb93cc585aa87bf31625663705b6827b4625f5f6d3f18c4dae563224c184fde23ebfc6c7fc64ab44987ced33383cbf6964301c12d0aaaedb00361d02a5c82c0773cb187f5050fcd66e3645ac25272bd65c3355241450ea3bdbceb9ae0a317da419095b294bacdd2453baf85fa1918409133672b1fa37953a5c6f62c3bc979bfcd9ad825be4bf3d6be5124af2829f1a50a6bf7bc97a9766836eedfed4d0378f0c7003c86bb577fb638bfb15fdd86f3fe6f3d40ea0358fa3d120857f58ecb4306ff7660efda445ad5ada8d62fe41cff67a6883c583d7be1522749a9eded33d69742cdf9c10d0824b5ba5854635424150a8dce62b57e45dafab3377fac642037d3375ac44929848e703b2aac3cae42cffe437e89175051f9211a0bd763d62aa230b55b2b9d0a166f56d5485c04c19595b9b45317441f42ee619f9aa9d70ce4105795ba9009339c0342d3fdf54bcc1969ce32706b786a34ab499506c48c94b8331c60124a8467267b78da805d0940e200eb0d95b077bbb43116baa0abee1ab66f2149e0c782f0ad43645dcbd490996b8b5ac28f106d2c64b799bc5d8e6f6790f1ee46c509b402d422285b4401edba76b9586ea462af37413eb507b294bf3e3b6231dba40e6e5e012306e6e431e03ad842f3c351db6778a15ba439e277f9991de447ea28a3e262da7b08afe3d977282632ca7fb0443f21f85ed98891b3d295e1978c1e2f62b100bfc2d02b34d191c0da887f89806017a86b021f6cc232d84becdd0fa6e521b0b0a4f58128dfb518f32e9508c943ff8a79894ead64ac0d39b814d6ab1322e8f21f2a32fce608847f655e864e315b6de1fde3ceb2a473b32f7a5c82dc55cef81d5c534528ee065831314544685a723a59b3506f52840cbc7522f032c35f071ea7e571a82d622672a429cf150948689b7e444e8762096c27b0031bce37a24cc012b98dec9e2bc0dc3d89ec5f035a9f11a8ba09327efec53f17d4706231ea8013c6ffafb749f77edd3290afe98487ec6c53a5e00f4cbc51d6af64d195ee9b0f4910567fcc9e2a6b3ba149ebdc726f37256edb0248ecb88d58c2fbc2288e9f86781e7f0d27caa9faaba04feaa80ee6c66d44503dd4e74912ef02d6da220afa6c60f08b0b33fd64830bfde2eb08e176b689deccdaa02ebaa57ab897fdd431db9988c4e2ae5f7ab8fbaacf6b01079dddfe67f9a4c1c583ca55149a82ac9e975dbed631a47a6d7756eb814bd73637879a0ac6cbecbbebb84eeb38eb93e40b89cdf9a258b1d65bc9195fc0a8ba61a35972d141be5c669fa036abfacaa20aee5e5a4dbb5d0ce11d59b885989f7078e773d94491b4d3a39d109aa8258e7792adf8e74ef2c02243c534766e0227c3f03c5c53c448f2b86e49cce3bc6a149010f8f2f49485e712f34017247183bb68bd203af416cccdfd98e4484f004a15cb4ddb4fd963c0a427456d27aee0ac5f7603bd0ff085c51d61fd7b12cdf9858db2f400d0c4e7a2e81151c752b74fe71072b69fd37b6f9892e2e5619e0088cb6203ef941f65e7fcdaeb857bbbc68246ec0f77005ba7760b1e575e6e817ec65f2ded4a141c23110a6c77562ebedeed9fe97252c4b6b1a3ae8143e70dec8f9a32788221979d6cd6b30bc92ac0de032f8e0e80ced467870cc4eb69e8ea69d1a4576b2c6c81aad7edd4f803f1ac97d219954c71e1aa196ea121b81766f8cac3cf56b0a96cb1453460ac6b1a9a74281ffd5d92a6483bdb2e825e2098c3adbc6007052ccce01f3d10f296965f833b8fd07b40ca9599800719e103cf1d03e5f339a3949a3a5f97193173e7734b2b21dc93b4e701943d8fe673bf728f7b9ea6a6f0c9620912d6aecef43acab79a8d8243587e22cfa6cdac7cdc7da77df4c4a54c319866a895744a7b7acacac4ba23154c717c43849ec0a1a727bd73dad1379b277c0d28942451dd20e78709f80d9e2af71a30cbfabf66ff6b1cf221993df2cceb3f81ff6e61b4c0decda32b149ffc4b7d3dde4baa5b0ab1a8b5d144ae5fc08fd899709b25bdd5ba34ce168b3d2f818c8b1cef0dd4c72817911b8e2a2ec4409cc1ef8d7d98d5a73fcc52d2c832ebe4f3ba439f5cc6f5b8e13fcc27ccd00d23507e481d31899f69f71e67fc64fb3e2e1853495c0c902518e6965b62cedd1f8df063245fff4284fb01b454256247cefb7190715a2c692d9921e78027e4a17bd20371da990e71b84b11663224fe371b2a6f390336043adade0dfbf8937e4f1246815e8ac48f7ce962858cb4422a3876b278e4a38ce2fe4c6cd49c9e372499b94891543cdfcbd1e7f7c9125e3897d56fde6604de14eb9705467803b4b661e4873211025eba1d188299d200bbc514f2106aa831b852fbad5e840bd3d8bc30c17fe8309d01a4afb1fb60e7f632c321df8b1d9d500ff1a8d69400011f48f8ce5cd2f14398d8b3ddc8f18f70efe141614fdc8a5cc40681e9e693bdfadcf19584e334ee4004169b7541ff7a678b6805ad64a62a6aca705b38a8860ce295c06333a113d09445bbae740dbe35378ab176411e74b6b19e1612f583581fae54ee66da4e6918c9e5f88ff21fe58b970458f1e63fab6d9eb052529d28b538095a25a27fda5a6c32d57d2a9ae4a29320afd89a92d2bd87d0449f2df68249db8c1fc1f621cdb04f57e6dd91841116c31d01eff6ceb26f43ee2d71add76cad9ecddfec92421e5141ccfb315683e09aad86664e9409b3db72c71132a8997cdb3bcba6cf1f0da0828a917e1c77e1617c00a23df36cb09cd7aa1b55d03826620ccbe8fb311cbc0c533039894f28a1adb01574b78c8a424ef1edd1cbd95042ca9fbd34fd5d1a65f0ae1974863922bca3a751da6c260fccd65042efd7fcd739847878ca404c8a38040b887c272e861c072b6860e8f669bd2d32d0d2c621f8b9cb5cf6d0d60b28fd279d05a4c213167f5f84b4cbf1637a34fa08888061f855316bdccdbf128ccf8db895de7bb21d69c3cea9097a834c269605b23d1e141a7f08487de406d91f006d61d64398c42a1d3df1ae6e1395d9b197cb474737de5cf905f72d2dcd47a907f2e6f47ad2884b66a895227890086a32485892c344f32a7d469c9ccd329153a29aaa42160a2b84797e168d7bd5c769bf0323ca431528a5d2413d8e457c37e005ac292349c13ce24bfa10f50aebe30b46ec8f0f49259ec53d1f95a1fa4eb900b692f5d450ddc35f181e435998a5e588a0c8af83a2c447f06ba97e9bc31879d17b43c6bfac3b206bdab3f495e86219bda72fdde4b447e48275c4f1db15ecc318d681bceaaee65735f6644ba2291af7dae46c51d828749ae4542c228a2eecde56c1d89f2edd14cc468b50384e7e362e70852775c6a35764322e387ee147468a5f5bba6922a327e0fb4c6409f8f0e6a490d3eed5c1db300dbbb8bf6df5d0dc499d6183996ba947604665499c2d7b727aa179b4483e3725ff2ed3457f7e2d73fb8dfbe547c0f2bd02e0b57a5f43b11569f967566bb2f1f56a17d95ed5630f6251e05d532c10b3a43775e9888d1e0837a8f2e93cf94c7fda15575cff73df55e59ddcf407d940872176a3b00962d5ffb36992d5c6d2b4aa89fa08447f39bf7f553223d91283152bbac519979938e287981063e9286fdefd52c9ba49ce03239f402cecde87c4575eca71e82637304a2022605c880be470b6d9062658a53f9f1bbb0cdba32c4b066da59b0dfcdd7dac56ae1adfe597f870ab3cf08717061aef5426e17cbe90ed2033fa551550ec7744949e7006883ac58771134ba5166313aeaff899cf6714b621146dc216bee7013352ce8d24e48a5558f81bc689891418b8cb5a936f97897712d4c3ca0b5482cb6b6350f772e89fbab7c657ef24491c1cad200ad96b9e743db5f1540b285a1515449f641298522eed594c43b33fda815ad12b4bd60146b4f1257f70a02fbf516e57c71c05ddfb97700be8097247798196a828dfef7d391de6b42f9e2cc002e83490ad5d1a67230ec55e025e0ab7fd61d57359d57b55539f4e0e8e1c729b72dcd63b4f6d8c998c77208bd29208ebd89b297f3bb952a2105c948af172f413bfb76e46e681e44f63fdcc7cd4020e81e03bdda01d998d5d5399eb197b74e5d6fafbb3492afde29ca22e4008b75eb2538f84e079813a01b703c1cc717a12e1251d76d028b7b4156f08f7f8cf07524391faea4b68b6e2e7423b13c47bf9793fb595c09f6273cbcd77297b2648a98b8d1e9fbec5e3e5246e040f68608b610ab1d5b237c90b0dfbccd9a15937826ef86ac7213b2ea4d158e5b86cc665785ea11732992d3e994f2edd73ab5be5e4e660c8ea1f5c57a7e1078afa1108bbd2cea23b812f64f5a976eff7d7efd1bfa86004f0d9c10b7fa92500f6d481a35a3d0d113b46f32fe9195c55017768fc9981fd98264554047f9443b612507043ff9460990421c26e232b8a17eb412433fa7f0ffb1f1c5e32dd745aade980bef3fa08afd9aa2c8cedaba3d50b943b72ff349979534a071f180b71ce6a282a192155cc3024d563f2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"304c15eb4b64e188ac1b4d9ea9ebc412"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
