<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>DIR Case Study Wiki</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #0065bd;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #0065bd;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0a1628;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">DIR Case Study Wiki</p>
                        <p>Enter the password to access the DIR Case Study Wiki.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ea7afd01d4c851871a20e8b0df9345a10b9afcf33e1dc507001979c3a5baffb1b245e7225d2633619380a7ac55ed2a3643f20d1835a0fccec22c0307a7541acbdfb1819d2f82709c9a7a604bca39abaf7fcf472348983aefb8ded2cc8ae6a6f76aa740893a61f9bb737b97f4d96130a82a77638a79375eb29779916e1c6552218f6056f69704aa8de4b5a25e50d3b4523a80e75694a708a66c95623a4fe0136c40c37ad99a5b643f53a5f3b2884d76e62b6b03aeabeadc92c59bd4e2266fa704a5a9e624e989a14aaa7f1c8a9e9f1afe022f9741af5f4741df8531b7e91008c9e7bad4a26d19cbbdb8612b90758fc6d88dafa187fa276d2a8e0924e506155a1a8f90573a35642e581eeb3aa1297884546188963badd8a7c9f8de1a8139045bc81e1593292d119ec275126e6e512d6451ce06a2773ece6fae4b3352a4f2d69fc80c9b3b496ac1e3be09048fbc6951e4b3e56fc8431f62ad1814b877402ffbf864b19452ca82851edfe7f49846c616f831671c9e1d1847c3df515a5c5c2af798349935059c71f14576d9f1c61d49b82d023852c739bfd3b4aabffdc7492af324601cd21a0de3babc84371881d59f32e69563d157c058cfa9e6b565ae0c7eeb8f22c993499f3ad68fd362a4351394c0b705a239e820d56af762c834a9d5f90f2a0f0183c6b12cfaf509daa0471ad062587ac46f8e3f370ff318a611e03b09f3b23a2ff46b413eaf457f1959391035a41f604b6e27fc230d2e81387e15df7ccc629b3c7fb97ebe1ec420a0b74f09cdd24edd2b3c4e017621db67905e8665b037ab19e4d13148eb65b6016717a9a80b6dd7df5b8fde969da9546679fdaa91662796d0db9c15aabb4a1289a01a30abda21363d6fe19916cb31fd7816528905e6fcaba88f5792455dc9bade20a8decbb74db28939ff29bb46525fcaccafff45e492e829ebfe79cd2cf72e22689db044bd6ec39b2a7c0e90a3ce94e939d70777124cf0b043dc4939aa59e96872ac4d43f39781fd5925408eab2da9c94118ff5a23afa05a8e35053bb7fa9138ecc5e11b1ab7037f3f96bdec5cdf2e2b9b73cf4d60aff03de0d846168e8b7cb581bd5f0d9709758b9b784bdaf632bd16e535b71acc6c9ba51dadeaa386434aeaa728e4c88dc56bc8e46a6a50fa898bd5c980365adf174add0a651717eaafdb84750adafea6a42bd2c051b1550641803714592c29c695474048c4666ad2356482be1d17e8848201a2c1332a10727c014ceb2eae473b4f5c9bf33a793cffc57c06690a8e2fa56061816d70c3d260ef5364d7db231b02ac73dfcb80af15ec79c81e5e442590cc26573ac0d79566952c394745fb5f7fc599450d4bde8e5924bfde1f5a1d18612be8b018fb6a7725016e99ed04a8007c1ec1603decf681c2c548bafafa72d2084977b8a04a6ffb86fdcf8faa85af43c560ed37b7380dd339477904b2676c416dc8271ac8f93cbd6db23f124db502bfdb5df650abaf2b085d7b121f0d6872045f465f4a053c00320c62a18a39dba7b7cbb03562677beb7ee1c7f978f2b5b1507e9cf29db8e424532aa075b198614c81821b632d25305bc6aab89d514f93c9df868b09959b10dd93df2701cb8f085b9060e20d591877407d517beaca20279ced48f0981668bf4c913ce7287467cb69774090f98f87c8a9b60994d92f96ec0cb74759730c2352b4a69b091e24f3f5736a71b3b36592ffd5654b423664f5345f968f8e510fe210e9f8336d0e64ffb71e96c9571e97940278163a97830e4dbba1934d2e447dd4af54edf6c8c54ea60ee3eabb3137ced2b1c81b1e947a1cb16b3dfb837088c8c88861afa8ad4e3697b0a082ac1b0f6128978bf4b1af45657f9114110d7b81cafa2e57c593daef43feea24a1b71d293f7f3cbfc896e2621b22332817aa52f73131ab4389ed3f58f9329c542017b5ed0df48688b3125624e08b870e34bdf74584a07faefb1225f2ed0d7cd978df5829e33479ff5ad55202e8b9d9c4de7a0dc6ff24ccf78c52a7a30305e8d1bc91900d5c76b3778878fee680f2cf893c77ee26b917466579480315ad71a994fe2b9e79ed8d576725553ed02d97ca767b82d2b98fc9d7474c502166770bbb5766289310d79b2fa6abfd63b1f9c1c1813e82d2017faba8fc1f56216dac2598fe2cb0b7cb33757ad8ab5085551733bdf86f3aba6b9e5d0af770f4328aa8dc08c811863eec6b80ba3ba7924891698dd561ec89714f14c452041fd0b3e4872116a2da5a27d6a0d7d4dff614d80418b789448fdc76283af4a9be3d7a8feab1a2bc17663c713f5c51ee918904fa7726c7b2b8b4ee8e43df7701710192b945d64d1d0e7b669b5d7a7216d90028ee3d416883727401674f72538936b2cd604ed87ca1aa0b2146ecede6cccc14420584dea8dc9ad7d6af006668f4bf4243d3802c8920d37bcd3e2547d897ca77543bdde0bcf3aa3966e91c08d4b44f9b333efae49677b51b1bc11df0d245ee80637fa4e7675b26a31e7de014027fa81409da0a02fa864231ce6744f035aa218331e2f724339143500628cc16938031bb536be4b979fdbab9a2132cabd2b3e4ad65d02180612d4e36e642a4f98f92568ad6de0c60025ab1e01a1892cdb4a646075971e2a6786a93523987d677abfe0f3cb13b95bbc97bfae48bf502a40e83c94797a06246053efdff1db3992b0740c80feadb45f844d36bbb71b92e75ec7a02e830015d62ec13072965b609d2ec5eaddd13d5f9480cb0419159ff91127a6d34cb78a8efed640cdd69454b3cd6b556321ae2418d070d333567f97f6ba1fb05043836989857e432b04df71d34ebfb48cbd27e847634bdbf74c9268eccfb1995af73cc30def18c26aa039cfd910801e488e3857661865d7ffe2a16ccee87fabbb323cd05fa709403a6c5f3231ba0dadf43b1469d3ee8bc565c19885bdfbb99710101643f0b1b6f362fdd36cddb3eaa69a1adbfd95652b17a29347980f437a4e9b8a0950f3ded5da3ad4dc270fbdf3a2792ac6b143a129503cccd4d9cc4d088759d70744f6112f8df7a1511e480208eed3621e27b8ba633f5d65fa9ee24944e757b33f1c8ee7441c441da143eed72af73a68d236a90b1768a98e0f35e03e2d244bcff5486ac358b8c4530c4a86f94bfa136b284935a7ff7c77b1b8165a9643f70ef6166977cb6179172a03bd8025592b683966cc3f48e59cc5b8d863c3d7ba012f510293e33db0a0fdb9dd5a89dc98c439b6b7cb5b5f7b4738018cb9e6402650537b44af017e4c8d1412edcab0596b67d6a4bae3b4e5378fd41c468d11255c04233c65c68df8b88bd9a3c5b7061ffe4e3831045d444693dbe50326c8f8e1ce1e98def54b90a6dc21849c7d714ced553d0ed3cbfa99aec4b0e556911d9e5b4480d3e97983c6d1dd54e34e8b5335d3fb61866d97401ed76993efe54925e61cb16143559325f7d574cbbb6d079439883bde330c59283e707157cf6ff866cb5e4b35ea88047bb73a6d41be88bef2fea8fd0db74eabe9954950a2ff32767b29161e1f73a4025032aa151726f24c65b86a8bf35020da41056b4401342c3739ab6551efb9238f1f2fd3916c0329ed37fd02b6e0b538092125061bc51071b211cb74101bbd3b0ebadc60689c9b2c20389b296aaea98c59e98039803a0a57c5911989d56acbd1df65cc0131c6d3a4e91467c172f70a8144abdd9f076c4143cf5501205200f62f6f78116e85f49daa0f0416bbce469f53d34abfdaf628e42ff9b578a3b4aefcf5b301977902ce25451c2b4e362a62abce665b601b7f13dddfd4edb811cff7a8eb32e3f0903043754bb7aeabb29124303116ae120d723d28335b109ab9648feb7e5b174d35d07838fed7d89361c50e50bbf8021c7912c2eaecf543d475af04f84da9c2a9b13a7784e1e5490290feada96f9ecd9b2e43bfa16d7319419cb9a246d81e5eacf14a97597836dcef23612b7908571850d47dc3026e6fc83c2e4a7be9ed9f7ce3f272d7c645c861180d16ea8ab7e756a02e87b93b389c5ab2843fdc8a71ea455cfa8c7a910f9f1c5aa06a025ed91437cf3071c36c519350b79b03ce9f4e58b37452f7e8f9509ed67ba09609765171680c3eb41e7632a1aa13a423c70560992c82ed682c34d1c791d6cd2552a1280be6b378f923d8bce208939490043ee65c9a05419b160702ffeb2f24e854302f28cb841dfd870d3c547031be00a04cb26b038cf7fd4f0b6a219fadb21ea1790489438224310fa57f44d1985532bdff645f23a04ebb694221cc16e0516dd3c115b0e3dec01291b9ef76d961fadda41c8cbe853b87c8eb7d5e274bfb36b1ebed8022c09194f1a8b18309200d1af97340b52c63454b748ffaadc0476383b75bdcb5c2250cbd2cafa09f792ed235ac928e8d890120b51b50a9ef318210a58116d6a1fea59785860d6e4c071f93d63046d1f43ec4210adaf38683089e48dea56408fc57217a178af42f3fc20e9ae4f9ac90244b0649de34ff090b032372ab3c25895b0d0e2ca3da0f321c4c9d14137f5bd2d02dcd412264fa50c60c6156f7060911e309e1859a333276441008718c1ef433addf5d63afdbda2e588fd67e6bebc57e59bbfeb6ae297556b57aacd9eca89582530382b77a9096604abead83e87fde55478a28d5bcf4593b9bb6ab75fb9926d898879e730378012bc2e5dfcf81031a892aa5f4ed627c53f658cd6eecdd7d932fdebb82582e4aa1cb582430b89e63e390877c9e53cea50662d7f17d313b6114d81120d5e5c57d289f32990cd6e414ff1fc0fe6596237e835d24a28a7c8f507a946f43710403454e580ed605a2b72a755fe0327d1e54e448d25ba7643d50c2a98a1ee1092173842d685038d11ff4a2c90bc465a00cafdf148f4f8167a05af05d09c97b8c764199c60314c02735a834e704d91260e96f590d91b8d61f41ecaac2e5e7274b6cb96fcbc1cec660e713ff2a797942c0ee5be2abf7353126fbb332d721fd1ec14eb336158fb20e678886fd0fca40a913356b847dc30b1cfe68c3697f3629b1c624dd3b1d1215e8509b8a666facc173cca7c2c48b5f167dd4ee4c6366babee6bb8d708c53050b5496d88cc4578535eeb404d2308a0dcbbb8b9dda5585178f0cc230108285177f3eb4284c28a025a40c70d5d7bbdf7a443a339daa4474806fd07b48c48968ea768e76688d9ca7ebef13fb081f18854cc48e23d7e1a03ea13c0cd0178825ac256b77dd84c7d1b837117a1649bb37aba31f2075e1bc1c27dbfb8f29d7f05c7d09d4251cb453a141f55c3743e25f6f4708bce30a66bcfb3fd73b2ce7f593c73bf320fd3abf07543d14c3111f1b1acd646ad22209ff6288a54a58baa14e93b4436cede55ba110e31b18794b3015b498dec6c24e8144c048dcd5a84326e68b5f2ef0b9e5135b7f1ab327f55ee187ae4df59c5124415ecddc3845df2bb17ca0b7777390a00c46b7368c7c2e21855a575a7ee77b2882784ce4f639ba55920d0a063928226798146341d415212df489f3f66f6030c13020ea7b5977926a0c8dd746c825c38ada3572b349639945203bb649531614e6926815818f0a380cfa89b3b5bff40e9f94af2fe161388acfc288a176138c48cf93fc30bbf5a45e1d4afe60ea5918320354694c38679c94b0b1acce8e9827eb9a485e02f483f15c386772f4b03c2d889a5862fa8f1b629d2c5f5c538817eea00fa846c41bcf25b2c3a36ff379489d883911ab5550f03a20d084e3d00c6ad576d4ca354e1fc8fdf115ed7929d8a4691f6c95c914d0e982f942938dd774b54957dba5c734ee28ec79b5ead3d72ca9cf69ada98a0a20286607e801f49d0fd552a6560f07f66e42b2660a3d34e4214082e5adef3971f761c04111a0f286c517feef2148b8e8da896546f77388e5214add26e9dfea1369978280b01cdc75f1da5250fced6312eec7a8f22aea6e1c0fe2965d419b0807bd12950dbf22fe18c7f9f6d9d1d08eb92b4b1ff27d53bc621853d42103e8bb7b46c81e0b77d181ea0fcc0429266c326337244627932db3d561b1977a9f62fb5075014336a42b9f08fe9ec0866cb783b28060014097326eafd8f11cdd66931233be3e43e9872928859f59046c3039eeb290e6187ecb8727c8ce611534d2bd6682b2b8d50029d69e7b3fdef2f5aab2c0c6cc969017574b3902a6280b208220f0d1cdf67c6b95ff60fa6dabbd67d21e19e206b0e75d827b054e571d0e6f2816339d6794ff87bd63df9dafcce528ae238f4f379168d8ce603e9db9b99f8d1b49e1270f9e35c02fd5d9c9063b752756f62715b301b65c4f815ab9a962257cf77c7e55c2fdc6325868b9a015ac63b22b3d78e841cf775f6ad4515e1f9ac14277f457a18f4dbefbaed5557b00ab1fd2567f5087741776fcf8a07754fcf53642db35d16397652c4fd93b9fb48d10ca12a3999a36d725ab4da6709a126ee5e5601a8791e47ab111984250fca6a1350b1b9a58c7b2f9655741a2975716639a8fb01c346716ebf87865685af28765780fc8d162707e621e2947e9086228e4cc75e4e8d03ecfbde86e8e1ccb7766d62eef60fae3d3f7fc064f4f8cee3615cd7172948592dd36df35e2182db96fd046f068493c4603c812124aa767f42db2e58b41468996ccb651ae77d2b033434ce1d0fab4e88b98cf8996cf6df0121539bed6d9361b79aa496d47a693e0eb459dc58f42f5ecf111ab35efdad18c8a4d9d04f77023937f1d54a17c4bbd4faa2431557b8149ee32085e156f4614528d143c57d5116ec2768fb7a0841196a433372b7de74dd32bbbcac7a20e48ebbd689d96fb0c04a3af95c778d8adadc358fa7f57940f3709bf2e9cd6089a83eb99764d381ced64b1e1b92266f1cdbf4e07439530a57b37cd6ae1f76abf241d86820b1dceb344ee2c78ed42d9a1a861d8c49bfadd997062d01c95ea892d657735c5d97d4d0b802d6ac570b778c82338e4a7c53d042f4af0e6c82e001e335bde5897bed3465b26324e5269ccf391904bed4edd0166e66d8a479e07a263331f7574dbc8e9c7fa96901c466bf617783e1c910f7bb5c35d62728fdedea06853df36930ddbad547e81afaeb9e26c310b9224fd123d7bdb2e3a32d8f4af36e724c68b572682cdc7d1b7f7c76608c3cdf19db0fafc2875df1a2c5326da51286cfb6861ecd0e52df1704f61c65dc986a381001ffbe1f57f4b693392245b8b04867ec301d6f3b21eca641101b9357d449e76e7bf1cafbe3545ba5e3c875a14415cac4d9857cb5697ab300ce78ff717fb7cdf83f46b72461e1bdeae6030c7d78e3a0907e854961897be8b01e98b3fde264d7bce5c0e11fcc7c6b1941aca2f140e29653a3080a850cf9727e769f747ac04efce850700e90b6a2b1ef9cfd3140bf6e383b18175b94560228d86973c939b9d59e1946d802f440cf0fafafa0d278df0ba8fec8df1f91c95a643e5b8e9b83c98a642dfa50f38333d5b38a0426e16ebd578f6ccbf80ced8c7d55f1466fe0a540d0713232a12e875e04cdf87e22d9a1e7445425a061f3ed7da115a38ecf324edc3b78fa3c30c7dd56867ea392d4e826c3b49e71bbb226a809d28f8c515f59ffd8353518094aafea20a4bf021f5b51f56d3286d38c4cad31f2e6f6dec10c190b32cf7b9ae9c7ff3a51adcc8d469a1cbec7560a0288a0435685b41ef6fabb0ac8489f23cf9b5be2e956d4bf27fd3969b6c21ac1fc8cd1c45c3580cc201b11464e5b478078dfca444a23781844397a0f3224adfd8e1af1be9792f99a3123bd885eff074096bd15df4fcc8c2779faebd9a016657ce262523f8a7f2253f025f2cfeebdadb43c95e125ac62e771c501e3e81cce4fdababc59bfb5c256f37da7384cc5275805946be189144155c7215af4d9930052e56c5c4112233e1bf8e50f94a4de5ff9f1a188c39419896044b5afacd7aec588dec3e6fe7dc40cd3d3f7b03743f0f1c99de4a3eceffb6d3ca674acabaf0b06a0dd09ed9c7f5cbc91b7ba1088942cc61e38b368ee27c2092c69111498699c0fb0faadc38243f86c63760e90beb7864826db0a9918d70247357a21b9720f420f189d9d7928698d0baf483df73b67d72f6683d81e11f0b6c8a85327e3e41c0a5fc98fb039730d84eeb4b20373d3e0125e13a78f1a210c9a7696d3933fd3e0568a90e604749a93ba6d40208096493c183973cecd397b207d59e75b33ef676d88c0fb5e50f27dba3a39b12346e388ca2c840369de263b5a87660feaf89a34a7c20cb09838ae483d1416dc82c7e2136fef0809a3a2e161302e0730113b40c2e658e728e6b4f863201754172d8669dc600c8e1d958275afac9e4ff3df84d292e6b0e3d70eac2e6aa9582361185e44c30bd5cceecd1e99890f08ad071cc4d2245f9ca730b35d2b647cfc736d5fa67abd824b667e9d16813255c4282b3d36c3da0c28c1363b7a88a5bca6b38c7279a79116857a96c63caa85dd5b2cdecf0707248b582cb8017731a923530c6e2f2c847b4d19eb450f6c2b79e52cca3951a7c85d7e2e23e65425f868e952a781dc2e5d7b6374ac01927b7677962d1453caaecf56f3bee659d325c08e71eb8613d8200a70592adc1c29015278b8286c9cfc5137bd14b30e12af79d1433226ab2944c0d6700eaf316c6e4b8da9ae2baea1b948f6a9907e6aeeec75da29afdd9556096e48b4f67ffb578c791d356b687605e5babe6f335f01d01c6c7805b228e839eb2eb0b42de643ecc4d2f25e7801b5cc4250788b52735fec97d26a4c0d2cc220bac868ce88ff348bd6dd6965a957ec6b6fa4e7792c601b453e6f4acbd4b7bffcb6768ac07de6ca0260309576ecd2dbb55ff3d7f2a876cd78fdb6cf26529c85c0dc80a022699f5484155e5c5ae3c08920ae75f680f683dc02ce4f54f19fa1a9512121add5896e1c2257e0f2c19a9a69c7cfa310b6d2f2f06b1287996eb9548ec6b617a88aa58ec43845b107c9abebebae6c601ba90e4111a7c05928077e2973bb925fa06b7b5d761ecbf1f05bac09e13dec0345793b35b6c62edd87b77c47d333c816585d283afe7fb0a93c0fa69ac80749f32c446493f8ccdddf43bd5c3384c48e92336761a749f31cbf7d56ce6e76d083b2e0b82fd5f46aaa7546c2325cc551fa5eb3fe6486e4eb51416bd40852a70d49c51251d12e6617d46cb6e044850abd881ae0c7c8a6d73e125a74c382d30e2559962252159fe3efcf304eb31cecb0334b62d3b127c8b629ca3500e4023b89738cbd67d4e15d0895059ddacbc392ac93ea7e16e35395cf7a59f4deb64a74bac2714093f82e0f95c59ef902f7c02a896356f7e230beed7a44a676a1f11bc6dc243628414da70830cc604f5ee7fe162ce769280aa466088010dc554c25175fac64ea6b4ae65f1f5f39796c9471ea338ba5305d044b1e35f1f711cca3843a0fb90f23aa2f2945cf9a33b6b2a8568fa6a088349b17d32e9cb4f7a1243e0249acc2f3d33e9d720d2838036447b7a7a614c5d656004f88f611a6751919ea60f97394410ee11cdfa053e9815b437ea3bed0ff2905adbdb0cdde753e295200e9f554f75156725e5758290aa3959b1472a0453deed7e21b62d1e0be2872bf696f4117d7942020ca4177dfefbdf9e96cf14c4fe120a952fb5bdda66e4a3c3a9ba736831763469e3c3df470183772db2b56441b30202866b81b4c8c9565be5775c4c65c8a2bc3293f5225375ce784fa2802c44a878622976701d4e6615b79066b411d359661a1c142ca72d422c7f694bbdb6de39d1502b2bf5a70fa1595955841fde8dc303dd2bbab2018b48e0146b58b9ea1bddc72b620f63e057ac6aed78c8cd18f3fc42eca87fd69a63dc0381f9d3cc64ab36ed976e004de0d0694d3072e34c835d30a2df7893b2ead738ba25ebbe74bebb3c21dafd4c5b424ee2c1b44f4aa5e0964453021b36fed4f682b14cac20996ba1a37eef741172b085040f9e06443dc9a767923c2f9f953c33a386c895b5ee395b2453f2218bca9c7c02bedf10f4671021737f9eca9ba85f8c116c83d9c4292dc68d6b9bb928b1a49400b6211713a40e24477f21b1a4f5bd76a9d48aafa03f2c9379a4b3b00ebc49821ec9b56784c68db2edf8ddefe919c0f75a32f3d0453dbe0d6f3442a041d61bd44281145e3dd92abdb51f0374f047ef6b06dc869b8b672ba0b6c65d8256d87f38a2c9beb12a424ecde10731eaf086c9307b09233ff5bbab6ae3ddb8010d62d7ceea4ac83a82bf9985a1d23dd95742a307b241cd00ffafb4dd0823b2602a26248f2441faf79dec3d11db4d303c18027a4ed5ca9f48c6636cee454ef5b128084724b697a87ae958cacfe815629500524811c0ff9b9d6b3c988a0329cd42dcafe3da19c62b6f02a1764f9742e1096f89254121fca4e39e1c8db24aadac80f883a5d37e37f0de42fb13d18fd643ef9301d332d7fe8da58abb8287e28ed1fcf4c3ec69de1de29bd56642adf6450ef46cca36c99d45a7d23b66468304657e26ebcf14dacb858a68478b894ceb38aed37054d14a3d5843966497b0bda746655b95e5c4431b90cba7aa52c4097cef76e5620dd011a5e1f48a2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"304c15eb4b64e188ac1b4d9ea9ebc412"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
