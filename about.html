<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>DIR Case Study Wiki</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #0065bd;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #0065bd;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0a1628;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">DIR Case Study Wiki</p>
                        <p>Enter the password to access the DIR Case Study Wiki.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5528e64ec61b53dd982964b7f8233ca8c822be3b6e69685becde2b27f6bb05c9be4f07a90695d74f715dc9709502d59b09ff7887fb41e1c52e8436cf761a4fbff3677cdca0ba1bf07aba1ed8885cf4299a10da824cbcadd3ffef91a1c93c318bdf110f148188d5520f006cbd537bb254bc1370858fd100652a16839b4e81b6654c44f61bad11692243d3a9d24e31a8ed4d0abd7e555a1e92cadc5dae1c12eb6a5ff9db2e619fec6ebb6eeb3360a17eb3b74ccc2d15246697497bac4df7539904d4ba2227f07b3e7ea3d4b3b0216a90b0640b5ad4b367024d09c12871905b3096f50b159f3af3499c1336b116cc3c3434418ac456fa13261dcb0d3d8ad42c89dca4ea1c361a400801d48f360a507d738a7e8850ff06703c2dff75630ee4d9def54690448be4d5fa71e0cfeae545b3e76aed5a40052692ad91b8b59cce1adb0f153c33029d46ffddb9145b0305e4480b8e0f0b3f7c9dd98b9bee5b67224583801a938a5a51358968a34120fa9b48245504ef152cd7d5104e85a3a757409ba67aa19615528d39408bfc4ef9e383b3661cbb2b1d31aa4f00d742cd117854759d7601ed08613cc592f809167f6929cbc2ddced645b70ee2258927d0790fa564176e56b0f04c048b675927126027fec393462ad22a1078431bd54f0aa96f77abff6798f8223bec2d7a5e9a5a4b3c2efd8ca5f703350d0c8c12674543f831957c01db29ea588985271e2115c87d3a41413672d504424214f023bfc26743cd2cb356466ce28ccd63cc7cf3289c13408275c1d2e5ec25db4a138e1844cee1592e41c7b79715b4efbbb3c3db40b95aa3062cd60e07f68c5d985f5affe28a2a5f063cd93ddcdf1171ace300790e0ddacc8ee6125ec830c7d300366d5e82213b9b617ef5519134e00a3fe7ef15c27cb161b5966ba72b27fd6fda700764772acc212c3342df5031a452b5d856ae5cea7c4ee60ab2104a8c2f2d27a2da5f8f6ae61ee4e15e0e1e5c065134e0d382fdd708113befd01c18fde302a01400af20e8279f71343209314ecc50441bbb25c1166dd1ecc641597e80e07d86a779bde1478e194ceb030d6519cc4ca4fbbbda63d63481cb16478dbc1a8b18a5f28561d8ee024bc565e58d2e3e9383a39dde20cc356f42c6b8a250a7d5c1e03fdc67194511279b273a8573c1c3770f0bc748f5f16c1df374fcabcb0ada0d38b24e40faf2823352e324413536a0ed43a7ce03fea170c5b4d2c2378ed6026baf57d8b9118dc35685a611bda87a2ab133251c95bad6ea26b235a19384108ef874417433e33e932bd9dd0300cf10ad504d97bfb27e53fa09750c40ff1354f170ee4e1783c9127daf5c91415574a91f6ddab9cdc5e81508b2a09ba3bba96b6fce82f12afc9f0bbb9cbe68c393a27184d15a9acc0dacb6aa563c7d03c2f3d4bbe6762ee252e046dae242c7ed05071ee4184129cfc08b5cd2621d624c51639ef8253911eb9718914594052c9be16c2ded0e2256d649c463b4d845eb3398822c434db844d1213e2c73de757d2b3a4e82c04331aeeca53ae4a0ec5cd158c8ca9b5b402022a6b0bc81084a5b5e35796dc0cefe3e9f0398aef68745f12efb4b58a2bee4d94264c1c11884161e49a99a63685cfb6688864b4e72c328523c3766919551be4676ccd4efcdc2023fbdfbcd99918d492c73ead9a845cd1cd70e09d9df940c60825b3fa7eaca3c18ef4e8bbb83c876cccc7d37065f5383b6cd38703b95cd5fbcee07ea811b7f5f029a3b04eae6a6c638c03968325b2738fd35c4ce5424bc7418f534a8280685bb050393d2b5165303609ef8f09a88ce2a8ec4bc74475dbe2d0c520bcc609b01ed01d0aef8622ea05853e8eef30e462c773950142c49cbdc6b82d381d9c2934b14f97f0187683321ce1f73620e271f99f3bcadc029e05e4d3396c5782543e746b9bd146c415dca84ef0ac85c6090536df1bce31ecd5c21a080c5022107698d3a262ba18a674f3d266cb3888337fcfdb7ab0348829509beb7de1b4784caf94e882c54e8b892be23cb2a8448777f93d99d963028913443d4c454d6e37ecdf04e56cbb656c05baf0feee04c6fbfe87d77705f782f6df578ea937cffe91fb1b8f0fdc645e61f3f14ef2e076a316c426dd00b7854f4338c92c09c2935f72740416d40382eed5198c30b873d27480924b2225bdd8e037a3486acd0e0bec4e761d7421111de1b2006ffe5c0f90673820c067a7e102a5e8f85bb82ba830187891797a3af1eb898d0ff0150197e35596707e92f70b483231c2e45d92b3af6bb5a712ad6e71b3057d9f8e2b15ce5b6c2b826991b91e987f8ea6cf90205fdc37e94bdbb0a8b7792dcfd47dc2fcb9a25663fb8f82ec00b7acf60b1ae509d32aad4f5d2422f8f3b26261d3987c28373f4273da6696d754cb1aaacfa8215bcf86cfa5c1408db33390b993903de2c983906ee31d035e5cfd1162b1974268454c4b133127fca5f38ca0c2bd1999ed4240be2e57fec09c2a54ce5c26de8047aed89fdc7531f56d652fb7b680c96a476caac075c95381be919f451ffd29b242c0a3d69f86513b7903c94e722fc60613ac4f047dd4446b94753b636d54edbe61f61b6962dd673bf52996438a43acf6bb5e670131d387554d6fca4ab504abed413506aeb3830381123a68d311046bce673a1e34ad4a78cff11537543168eab16830b5f24b96fa384989fd1e8bd3a3d5520e71c2bd42860714303c5b8814fe07575e0d3c22cedf75789344bdd29a170db2023a7af9e4c2cdfee01704905a19a5bdb4bac353f4e536cea6a381d5dd2b55c3458bb0ba0e1413548a83b3bbae5855d6d985dfd8c1af174386264c896e1b9cf93f452f6883a4b479421dc04c6ded4bc83eb53da95a477b9af05ea5e7da3c14dbde96777bfb670df3f4d655b1236f62d19c2c40ec36572e86d4378b847abbcf135629960f74c9ef4a28dc0b7d8be2c0fc06fbab24e547495bd4061dbd439cc7635be782874dcbdac38d92fe3778d68d7acb67fb56ad62512cf5950045ae7a78b82f256a9d11fc43358bb85560e78ba66679e3ec4b044e9c74a00db09d56756b0ccf8ea7dc6984e7ef1a7e69a0d6c3dc834e23bbd018e3a73dfae2592fab3ae535d89f509db9578472aaf4f005cae0cbed4e330304e5d2a9ccfe4ddab2091ea12f7e9fe5b14838f4cc931afe4643ea0a5cec6fdc088419b1082ada122ce8307cc993ad29707f61f13d8bd417c9640852e1d23a0fea3143a39fc7732a5ec6ac0b8d8624f8132f4dd35e6d180bb5db8ed93c637a8ecb38b33bb3fab59b3912b424891adb7a9039b12677c174de53051b3b18a95d546b2283f6fceae7042dbd4f64cf776a32424d943b694aaee7598ed36093703a3ee5a4031547090495f5f7e0666b3b24299ace4ef7f259f19acfae7a6c03808da765fcdc353929fe498af0fd2c2c6e27699e9ada481adfea6740a4a56b76785aec1d6180b2a0e2a1fa66bd6b7026f2760b70cbe2f33a45e5a1a29a3ac2c958129bff2e80afe0b29ea8635c30346059d80a24f2f31bfefddf3a5f1eb0fc831cbf6b5b4dcbdd113809aa278b85f60721751c6f7a2b6084dc9a9c49722765a8822c6447f17a10defa7c46c1f6c4bba4dfb2362c02475f1dd13e45142ca8032a9b6c65d80774f1af323f9078ba108c2acf9fa13a963d8e544b78684dd6f2930ba3aa970d10227a2603e1d9fc74e0f43da3099ee5dce6b871f5589b9d7edd2202fa294f5990ff7ada356fae81a42e5c830cd388f8cf9324ab1f52a956f3a56de61bf7b64a2248726644adda38cafbe2f68c1fe1473521c9f770cf30168d05c8fbaae163f599542b4e7a897dc66ade4ea6298ac59e4f4343430966ed55f90465a0aad0bfd055da4bdf4e46e6584784d9c00d51e0c4a0c387910bb889d971ba91725aeb560b1000011573f6547871b1c5767ccbfffad0ea669668c3da7e0a9d5ac9e163762748bf4711d5864eaf1651eb146e0fb611bc5596edf9ab2c6e86c2587194aa44fb621e20e4c9a0ebab044be1e17d689539ce3eed1894dfcc9d80cab9ad9c14f0d4faa87bab7ce89b68d067462e1440eff3ae36fd8b7e3fdde5f1c8c129f745dc4a04b781c392a37ea0a5e414251a3353352f30cbdc85dba76d22cd2bca5a29ef95ec6f9f102a121c0bb56c558f718b49d613c95cbb5d690be8dd18510c25355a88b79e2457ee307caa13ada94b834a1081ca9f5d04f4d00a34bc86dd2ce387e35768b3b0e051b00d463e264065e74cf78fde57fe25aec765af6304f999047cf85b9a1c04c44827c083a98d2671bc979693f771461298ebef04f790e9b12675cb940b719efaea70ab6541cfa3fcbd39d8be871fcc4e8f57af47294ab292bfccf81004f242c3dad8c331848670f18e8968892ecadbe721dae83ee32452e8b1f88ac26f0b36e117b44179003a8ff5af612f2ac0e9405a547d31744f35a458d6827e5cc57a31198f080518fbd916dacd39fdf2c979facb80c76b770269beb734494acef4bca567f3f7bf5628eeffd3fbf2abcb6ed15dd8fe8380a13bfec97295ccf202f266affe9b9f5f7e6c17075e57f99e6c1cb7e0c5bd64f607c294f580ab96dcbe9348825e21bf9f3b9e7dd4c326711b8ffeab0de186a42b4b52ff08dfdf829e2e44741d4eb1a6a47b0eea58ca05fb6c087d9e58626d2ccd64fd282f4c4dd3ef5c4c45fcaf5fb89def5dd25c60bba5c1f94f2fad96361ae5f1f5fb6cf925b653e83e86ffabc9c46cd9d403fbd7091de9255ef8e244457700d8cf64d35073aeabbef77a3a769c442be826ba99e3d0825b701394330fcad283f58ab3182b75662684cfb70b09d6a401c84776d2650af3d3d711c660d4c398c6342889c3ea3f5015a166a6a2411a81ee38bcdbe6e0fc89b2e8d84adbff2532ac4f45ae1f3174e903b95e6b7c73bbf1431d8a321eb3b8cb3de5eaea5916d48bdf77a6b5e1562278ba8cb50c6dcbf6e889d34d8449b1a8711aebbfe7b7c00947fab65ce35897711096af91fa07977085260b47fe220bcb7e8766e71a7a063c7972110b2d887edfee676e405cbf49aeb9aa575b52b6924533167f424073fda21a98bd4463b938a3862fd86da4c58b82985940e1e516bcd93fbbe7148b42b82f99a00a6b08b4bdf83e3532f7ef2bacc4b9aa790addf6934ea920beea527e331b2fc977033a529aadf7cf731344af6d46d9bad25ce9b28b0329c15b3c59864dbd3ff7ac6e75e153fe48d28ca1761f9ec1230635dea39bab3533ec38c96773f00b1188bd1de58c0a318cc7ea308df555337586e84b36e799a2d82803588affc2ab1eaa771b2c937f69edb8a6447a30d81ab511a7b0b4b21f7dcda1b6351bb3d9b60336a5b8b80e15875bba74a9bb88e15621cf98d85ab18f389b47003ae870738878330b1e4cc127e16654483d8ade966131e550dab866956c1a6a658b9f59aaea1ac8f9a636f42516902548a4b8cbdbe8eeb6ecbcd056d89f527eac2334371c84b59d57aca3ab6fce91cce1d5a5555085cc7e2ecf140b68991104628449aeaf1b42f5fdffc9aaf4cb8038108d0038ee3eaf88b95873ad13cbacdc54354b37f8b7b71369d037d33dc80a0565eaaa164c8dd5a842ed4f91d7e50a32c1c4dc9ad4d2ba33ac1062eb407817e2bf3251309a213fbd3e301455f039734932a1bfd6139107b5a1c6e7d75135bba6566a4e6df22ab5c6449d12a1e80870e9a0bc1f4ac6805fe7ec0e4b991f20ee127f98968fdbe55fb0ae13ac98cba638f84625af1427179285d51ab9a6fec3d3f90927e139b40c16219f336463c869b2b994ba5797720b2d4ed5c468523a3a6e2a3d8b76e551eac24dd960c9f8181f3541179ff19483190257e10e6a7932283a21ae5bc3b09d814e3cd4cafc8321d20856e3786a62db11dded86c62d10f783c3f79f0b5a417482da61b4ec7011082828db7ad227611ba356977bf2f4c8448936da79d35d13fbabdb40e07547debc16bc2cfa46a9c9dcd8040346cbb1b5eedf20833f13bdbd2287f7e7c8dbcf176c876201d78f6f912385f8fc77e40379551ed5f4aabbe69cc3b45d5d24e2d177eec505a1de9fa2d93d51bb0816ab2d66a8209644b234b4a0c845e8ab872433422c062ce62eb3c294bbefdcbff04f6d3ed06a233841df326bdd0c978604a9edc31b056314433facf7ae9936f398cd92d90988176b6e1c3095ace0b067f6eb413a3cddc7aa3fa7f016f7f561d947835d4535062ee919bded8456596be7b68112cc87ed6ba05823dfd3ba731ad86ba710fd03bfef7ee146b14d3cc8b1f15c13e5323ab1c77aa58354a08e263fdb97419c9d9b4d7eb1c9ba5cc3348f2efc0d139d67094c69e9a1ad15e9b49ce3796c270c9f485533d7c1915efd1114cd7ddda4fa8104e1b960791ff2a8f5c9c134e3772c4adce7af62e243ad20eaf709d884d692b9d632275a6b1478798e7239a7cfca376f70bc0e8230c9862dc635909574d93e2ab266f393ebac6328051891b7c1c69660415da2d050343327fa02a06ee38a5b0eafee36865cc706dcb10b4134e0af459b558aa47df7f4d0f31b847343c317453cd7908ca820b990afc18ed45b7dc5005b5641312f4f602a45daab7aebc883f4446ba4f3062fa27d984c3d2f8e0e2d6c039c4de6b2b804338bb5a2552c87d7ec084d778c80e756bb63bfd84811d68dca498f1503f5aa9042748c07e0249573ac1460fa4103a573f05f7b4915c45ed70a6aad3986d6afa93a8039d317394627ec629d7f45ecc7ef20f1f5353e3be1304a61b7cb863e8cee099ec615704959ed34e1f7de0e23867006ab36b89cb52b3be82ef49bf409a9c6c6bff3c8d7c09416a192a6a1d379879ef18f44580cb1ab83420761caa75aa5bf9c58f47be844002e1f0cb0e910917af64d785d5fc92fba48e1cfa8a2c8f4d98aacddcb946ec52b9141f2bd867b8ec0fbaadaa881a74f4e9f12897416f68167a13ed2e98071a7b019fa685268a375c9d2036c4753c92fc38fbea6615b9ded876b20e33519d6db0d167a99179aeee9aaf8fbfa7344d937d57564c6b7fa6665c90ff7375e978d719a9f76f148b82f2564d2be6c87172d7c5e5b33aa3c8657b429eacb5328f9764fdc50dc5d2305c95cd19e7cfcef216680b8951ed90f96907044e3dd7e25269b48999eeaf579c7533566fa1d689d30d96f9c0f84cac2a867cbb5c234c301319eb7f9786631498915b1424d47e19b5b416a72e7e6dea7aa7e945812013805886c175aa45f8a131cbbccab98aea74d740d415e656b30a6fb11188ed99f5fa59e601098cf2b125cef3cc5ec358919d13dd84aef6d1fe821671d9ba104b9354d9786ca00f59b81c98cdbec030c584b570b06b73523ac439c84b7514e3c8ee91fced9d8924dec5f9ac9a96f9bc6ac114a48d26c0d334fb12ce489e208850977bb5c09ddefe88813f488c37141a041ad9166f6e66e731a8be12d7e3c4d023847091c65e60054090f23d9dc9b5a3e6745271876b77913d04c44e4743165123d57701440b781cc715572bd20a0f36313b4eb540924f374504d88f7f521eaf375238c2b983c0022ce79a69ad4638d9db7c5eb578d72b1e5f58de9f6e5f83f2d28a28b80e43a6a15505b404809bc91b5a86014e16929814cd9c51f07c06ad4c46bb85a95ee959d715de6e38c86b707b9027cd46f2486dc64f8f11902f3b6f7c397bd9c37ea3f6646ba6f2c8151bc9cf725f5684b3b84f6faf959dc7cca43b2ec3c01ea4b6c265d9686b596e2cc62417d4cd12a494a23242670dc8366279841d0392f3e0d104a3be99b2ab15a98cdabcb1d6b29eea5ab70bab51e9ac72107cf0df3957daf692b203eda66f8cb4f594ec0fb6dc2b9d326f20e930f588277fc03ed3a443dd2cd35984a0efd6089a672aebb663708d584181e13fb8cb446bb49a4a329967ccca685b0b5c93f8e64c00a578b2093f9eb6118da6a33988912e06fe9a12c0c60f4317c115a0b28c4a2a6968ad1e911c7895516112f11fea1ddc776063e115a18753b86b7af3bd66a6f17456cc98392028e44308c9467348e0cd9836ca6bea9ecb635dc69beebe256bb1a1182eb2a012139ee7b0a222b2a17603a89af16073b6fa81e2a878ba491c542661ea5e75425af4c956931c5d3b42136a2eb380d1a80ffc8ef694c174adf9860ac938e00fecc83bc7142760228b31c0bbede7157ada5e9ae24b025ad7c8a7a94116b2f0a149d2953acc781917091772957edcace2f3bd8a1610901bd2696b8077d599b8f2b292adbb97ac3d361f5c8e6d16a2ec4f47e0246f2b0a0c0f9743e32b6ebaf186e11a6075504d2e2c67c77c0538d4b07e2a3782196ac23e0cf5e2985b7ec5ced8c981f6e8d590be3d5536655d93155aeb6153db019040716b3fab27b1722a4a973d5ace30bec5c20f7435eb10e2f5fc3641e2a6812f8db264b7453ebec667c4c6c0ae6300497e4dade76bbaea426ad6d4808cdf6b8a25bbefb821b647811f31abaca1e36220dbc655df99e208ab7d01b644bfa88e88d5b29802faf7b296d931886acf97c7d78b4460995b2299be7d9ede1bf1e590ed9c48a552ef1fda81f299684abc69a11d7bc5d269414bcfdafe516f600c735b8e5879ba3979ce6a36f138619ca667f83b77ed94ad4b93e9797e284ddcb318cbae9cc55b8cebc58151f67ecd1f2d0a7ec8df0ff5fed91a7ccb145d2fdde544dac20afad717b00e2ff5cd42604a03ab091be3200488638f585a0638f797a10fcbcfbdbf80571bb5d086ffd310def4b473b981610034b8681efe84c28c1cea5fb37d8307a5992f6663f765d3d6f8bc6d28762e7497dcee0da01407d953341296e07d69ab7e01ce59f6edf1b4307926ce8d10daaa23037d47d7e819c1af027b99ae317fb76a120dd380efe8885e721b14bb9dd9b0538169302fa266aba7c1c20dd2b77d40359ac94a2fde9eeeeef60f11d3007b6df35732e6904b8244b85e0c12febbbd75359da86b52e409a66035a9e5baf52dbd3d87ddc76f0ec94a29aa0d8f3d698643c4859111fddb55c1d6e7ccd4c7ccb3abeadd398c47f007d8f49e136286c8a3264d2e9e7b8f48a4088e5fb7ad7f70ac0822c47aa116669c9962b4d24884ee1e0db3a1cd8058799b1f387e6345ec43b32019137753c249bb84acf9d5a3412f26e92c839e55e2a0cc72798e5e849237f4b9827a2dc264423d330cf8f0776aeb2ef9be5426b3708212d62de6fede754f5f4176b11b401ec53a5bbc03a2c61b99c2eac5c6c1d4f4e693aedd91a94a4921d7dda821e111a304d30fd3db72af13397f0bc3db06bdd30efc5db6680b4732efb513115a7d036eed7db2c4de0d189b8f6eb410b5c17dc1","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"304c15eb4b64e188ac1b4d9ea9ebc412"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
